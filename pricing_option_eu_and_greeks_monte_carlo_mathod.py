# -*- coding: utf-8 -*-
"""Pricing Option EU and Greeks Monte Carlo Mathod

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YP3HFhutSfwKYdiHQz_0nNbfL1XjNVR0

price
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# 
# // Fonction de payoff call
# double payoff_call(double ST, double K) {
#     return std::max(ST - K, 0.0);
# }
# 
# // Fonction de payoff put
# double payoff_put(double ST, double K) {
#     return std::max(K - ST, 0.0);
# }
# 
# // Simulation de ST sous Black-Scholes (mesure risque neutre)
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# // Monte Carlo pour le call
# double monte_carlo_call(int N, double S0, double K, double r, double sigma, double T, std::vector<double>& estimates_call) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum_payoff = 0.0;
# 
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff = payoff_call(ST, K);
#         sum_payoff += payoff;
# 
#         estimates_call.push_back(exp(-r * T) * (sum_payoff / i));
#     }
# 
#     double price = exp(-r * T) * (sum_payoff / N);
#     return price;
# }
# 
# // Monte Carlo pour le put
# double monte_carlo_put(int N, double S0, double K, double r, double sigma, double T, std::vector<double>& estimates_put) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum_payoff = 0.0;
# 
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff = payoff_put(ST, K);
#         sum_payoff += payoff;
# 
#         estimates_put.push_back(exp(-r * T) * (sum_payoff / i));
#     }
# 
#     double price = exp(-r * T) * (sum_payoff / N);
#     return price;
# }
# 
# int main() {
#     double S0 = 100.0;
#     double K = 100.0;
#     double r = 0.05;
#     double sigma = 0.2;
#     double T = 1.0;
#     int N = 10000;
# 
#     std::vector<double> estimates_call;
#     std::vector<double> estimates_put;
# 
#     double price_call = monte_carlo_call(N, S0, K, r, sigma, T, estimates_call);
#     double price_put  = monte_carlo_put(N, S0, K, r, sigma, T, estimates_put);
# 
#     std::cout << "Prix du call (Monte Carlo) : " << price_call << std::endl;
#     std::cout << "Prix du put  (Monte Carlo) : " << price_put  << std::endl;
# 
#     std::ofstream file_call("convergence_call.csv");
#     for (int i = 0; i < N; ++i) {
#         file_call << (i+1) << "," << estimates_call[i] << "\n";
#     }
#     file_call.close();
# 
#     std::ofstream file_put("convergence_put.csv");
#     for (int i = 0; i < N; ++i) {
#         file_put << (i+1) << "," << estimates_put[i] << "\n";
#     }
#     file_put.close();
# 
#     return 0;
# }
#

!g++ monte_carlo.cpp -o monte_carlo #compil fichier

!./monte_carlo # execution fichier

import pandas as pd
import matplotlib.pyplot as plt

# Lire les fichiers de convergence
data_call = pd.read_csv('convergence_call.csv', header=None, names=['N', 'Price'])
data_put  = pd.read_csv('convergence_put.csv', header=None, names=['N', 'Price'])

# Prix exacts (à mettre à jour avec tes vrais résultats de Black-Scholes)
prix_exact_call = 10.4506
prix_exact_put  = 5.5735

plt.figure(figsize=(12, 6))

# Convergence Call
plt.subplot(1, 2, 1)
plt.plot(data_call['N'], data_call['Price'], label='Monte Carlo Call')
plt.axhline(y=prix_exact_call, color='r', linestyle='--', label='Prix exact (Black-Scholes)')
plt.xlabel('Nombre de simulations')
plt.ylabel('Prix estimé')
plt.title('Convergence Monte Carlo - Call')
plt.legend()
plt.grid(True)

# Convergence Put
plt.subplot(1, 2, 2)
plt.plot(data_put['N'], data_put['Price'], label='Monte Carlo Put')
plt.axhline(y=prix_exact_put, color='r', linestyle='--', label='Prix exact (Black-Scholes)')
plt.xlabel('Nombre de simulations')
plt.ylabel('Prix estimé')
plt.title('Convergence Monte Carlo - Put')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

"""ESTIMATION DE L4ERREUR"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# 
# // Fonction de payoff call
# double payoff_call(double ST, double K) {
#     return std::max(ST - K, 0.0);
# }
# 
# // Fonction de payoff put
# double payoff_put(double ST, double K) {
#     return std::max(K - ST, 0.0);
# }
# 
# // Simulation de ST sous Black-Scholes
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# // Fonction Monte Carlo pour le call avec estimation de l'erreur
# void monte_carlo_call_with_error(int N, double S0, double K, double r, double sigma, double T) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
# 
#     double sum_payoff = 0.0;
#     double sum_payoff_squared = 0.0;
# 
#     std::ofstream file("convergence_error_call.csv");
#     file << "N,Estimate,StandardError" << std::endl;
# 
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff = payoff_call(ST, K);
# 
#         sum_payoff += payoff;
#         sum_payoff_squared += payoff * payoff;
# 
#         double mean_payoff = sum_payoff / i;
#         double price = exp(-r * T) * mean_payoff;
# 
#         double variance = 0.0;
#         if (i > 1) {
#             variance = (sum_payoff_squared - (sum_payoff * sum_payoff) / i) / (i - 1);
#         }
#         double standard_error = (i > 1) ? exp(-r * T) * sqrt(variance / i) : 0.0;
# 
#         file << i << "," << price << "," << standard_error << std::endl;
#     }
# 
#     file.close();
# 
#     double mean_payoff = sum_payoff / N;
#     double variance = (sum_payoff_squared - (sum_payoff * sum_payoff) / N) / (N - 1);
#     double standard_error = exp(-r * T) * sqrt(variance / N);
#     double price = exp(-r * T) * mean_payoff;
# 
#     std::cout << "Call:" << std::endl;
#     std::cout << "Prix estimé (Monte Carlo): " << price << std::endl;
#     std::cout << "Erreur-type: " << standard_error << std::endl;
#     std::cout << "Intervalle de confiance 95% : ["
#               << price - 1.96 * standard_error << " , "
#               << price + 1.96 * standard_error << "]" << std::endl << std::endl;
# }
# 
# // Fonction Monte Carlo pour le put avec estimation de l'erreur
# void monte_carlo_put_with_error(int N, double S0, double K, double r, double sigma, double T) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
# 
#     double sum_payoff = 0.0;
#     double sum_payoff_squared = 0.0;
# 
#     std::ofstream file("convergence_error_put.csv");
#     file << "N,Estimate,StandardError" << std::endl;
# 
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff = payoff_put(ST, K);
# 
#         sum_payoff += payoff;
#         sum_payoff_squared += payoff * payoff;
# 
#         double mean_payoff = sum_payoff / i;
#         double price = exp(-r * T) * mean_payoff;
# 
#         double variance = 0.0;
#         if (i > 1) {
#             variance = (sum_payoff_squared - (sum_payoff * sum_payoff) / i) / (i - 1);
#         }
#         double standard_error = (i > 1) ? exp(-r * T) * sqrt(variance / i) : 0.0;
# 
#         file << i << "," << price << "," << standard_error << std::endl;
#     }
# 
#     file.close();
# 
#     double mean_payoff = sum_payoff / N;
#     double variance = (sum_payoff_squared - (sum_payoff * sum_payoff) / N) / (N - 1);
#     double standard_error = exp(-r * T) * sqrt(variance / N);
#     double price = exp(-r * T) * mean_payoff;
# 
#     std::cout << "Put:" << std::endl;
#     std::cout << "Prix estimé (Monte Carlo): " << price << std::endl;
#     std::cout << "Erreur-type: " << standard_error << std::endl;
#     std::cout << "Intervalle de confiance 95% : ["
#               << price - 1.96 * standard_error << " , "
#               << price + 1.96 * standard_error << "]" << std::endl;
# }
# 
# int main() {
#     // Paramètres du problème
#     double S0 = 100.0;
#     double K = 100.0;
#     double r = 0.05;
#     double sigma = 0.2;
#     double T = 1.0;
#     int N = 10000;
# 
#     monte_carlo_call_with_error(N, S0, K, r, sigma, T);
#     monte_carlo_put_with_error(N, S0, K, r, sigma, T);
# 
#     return 0;
# }
# 
#

!g++ monte_carlo.cpp -o monte_carlo #compil fichier
!./monte_carlo # execution fichier

import pandas as pd
import matplotlib.pyplot as plt

# Charger les données pour le call
data_call = pd.read_csv("convergence_error_call.csv")

# Charger les données pour le put
data_put = pd.read_csv("convergence_error_put.csv")

# Prix exacts (à ajuster selon tes propres calculs exacts Black-Scholes)
exact_price_call = 10.4506
exact_price_put = 5.5735


# ----- Erreur-type du Call -----
plt.figure(figsize=(10,6))
plt.plot(data_call['N'], data_call['StandardError'], label='Erreur-type Call')
plt.xlabel('Nombre de simulations')
plt.ylabel('Erreur-type')
plt.title("Évolution de l'erreur-type (Call)")
plt.legend()
plt.grid()
plt.show()



# ----- Erreur-type du Put -----
plt.figure(figsize=(10,6))
plt.plot(data_put['N'], data_put['StandardError'], label='Erreur-type Put')
plt.xlabel('Nombre de simulations')
plt.ylabel('Erreur-type')
plt.title("Évolution de l'erreur-type (Put)")
plt.legend()
plt.grid()
plt.show()

"""Réduction de variance"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_var_reduction.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# #include <iomanip>
# 
# // === Fonctions Payoff ===
# double payoff_call(double ST, double K) {
#     return std::max(ST - K, 0.0);
# }
# 
# double payoff_put(double ST, double K) {
#     return std::max(K - ST, 0.0);
# }
# 
# // === Simulation ST (Black-Scholes) ===
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# // === Formule fermée Black-Scholes pour le Call ===
# double bs_call(double S0, double K, double r, double sigma, double T) {
#     double d1 = (log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
#     double d2 = d1 - sigma * sqrt(T);
#     double N_d1 = 0.5 * erfc(-d1 / sqrt(2));
#     double N_d2 = 0.5 * erfc(-d2 / sqrt(2));
#     return S0 * N_d1 - K * exp(-r * T) * N_d2;
# }
# 
# // === Estimateur Monte Carlo Standard (Call) ===
# double monte_carlo_call(int N, double S0, double K, double r, double sigma, double T, std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += payoff_call(ST, K);
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# // === Méthode Antithétique (Call) ===
# double monte_carlo_antithetic(int N, double S0, double K, double r, double sigma, double T, std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST1 = simulate_ST(S0, r, sigma, T, Z);
#         double ST2 = simulate_ST(S0, r, sigma, T, -Z);
#         double payoff = 0.5 * (payoff_call(ST1, K) + payoff_call(ST2, K));
#         sum += payoff;
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# // === Méthode Variables de Contrôle (Call) ===
# double monte_carlo_control_variate(int N, double S0, double K, double r, double sigma, double T, std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     double bs_theoretical = S0 * exp(r * T);  // Espérance de S_T sous Q
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff = payoff_call(ST, K);
#         double control = ST;
# 
#         // Coefficient bêta = 1 (supposé)
#         double adjusted = payoff - (control - bs_theoretical);
#         sum += adjusted;
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# // === MAIN ===
# int main() {
#     double S0 = 100.0, K = 100.0, r = 0.05, sigma = 0.2, T = 1.0;
#     int N = 10000;
# 
#     std::vector<double> standard, antithetic, control;
#     double price_std = monte_carlo_call(N, S0, K, r, sigma, T, standard);
#     double price_ant = monte_carlo_antithetic(N, S0, K, r, sigma, T, antithetic);
#     double price_ctrl = monte_carlo_control_variate(N, S0, K, r, sigma, T, control);
#     double price_bs = bs_call(S0, K, r, sigma, T);
# 
#     std::cout << std::fixed << std::setprecision(4);
#     std::cout << "Prix exact (Black-Scholes)   : " << price_bs << std::endl;
#     std::cout << "Monte Carlo standard         : " << price_std << std::endl;
#     std::cout << "Monte Carlo antithétique     : " << price_ant << std::endl;
#     std::cout << "Monte Carlo variables contrôlées : " << price_ctrl << std::endl;
# 
#     std::ofstream file("convergence_comparaison.csv");
#     file << "N,Standard,Antithetic,Control\n";
#     for (int i = 0; i < N; ++i) {
#         file << (i + 1) << "," << standard[i] << "," << antithetic[i] << "," << control[i] << "\n";
#     }
#     file.close();
# 
#     return 0;
# }
#

!g++ monte_carlo_var_reduction.cpp -o monte_carlo_var_reduction #compil fichier
!./monte_carlo_var_reduction # execution fichier

import pandas as pd
import matplotlib.pyplot as plt

# Charger les résultats simulés
df = pd.read_csv("convergence_comparaison.csv")

# Prix exact selon Black-Scholes (à ajuster si tu modifies tes paramètres)
bs_exact = 10.4506  # Pour S0=K=100, r=5%, sigma=20%, T=1

# Affichage des estimations
plt.figure(figsize=(10,6))
plt.plot(df['N'], df['Standard'], label='Monte Carlo standard')
plt.plot(df['N'], df['Antithetic'], label='Monte Carlo antithétique')
plt.plot(df['N'], df['Control'], label='Monte Carlo contrôle')
plt.axhline(bs_exact, color='red', linestyle='--', label='Prix exact Black-Scholes')

plt.xlabel("Nombre de simulations")
plt.ylabel("Estimation du prix")
plt.title("Convergence des estimateurs Monte Carlo")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_call_put.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# #include <iomanip>
# 
# // ===== Fonctions payoff =====
# double payoff_call(double ST, double K) {
#     return std::max(ST - K, 0.0);
# }
# 
# double payoff_put(double ST, double K) {
#     return std::max(K - ST, 0.0);
# }
# 
# // ===== Simulation de S_T selon Black-Scholes =====
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * std::exp((r - 0.5 * sigma * sigma) * T + sigma * std::sqrt(T) * Z);
# }
# 
# // ===== Formule fermée Black-Scholes =====
# double bs_call(double S0, double K, double r, double sigma, double T) {
#     double d1 = (log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
#     double d2 = d1 - sigma * sqrt(T);
#     double N_d1 = 0.5 * erfc(-d1 / sqrt(2));
#     double N_d2 = 0.5 * erfc(-d2 / sqrt(2));
#     return S0 * N_d1 - K * exp(-r * T) * N_d2;
# }
# 
# double bs_put(double S0, double K, double r, double sigma, double T) {
#     double call = bs_call(S0, K, r, sigma, T);
#     return call - S0 + K * exp(-r * T);  // Parité call-put
# }
# 
# // ===== Méthodes Monte Carlo =====
# double monte_carlo(int N, double S0, double K, double r, double sigma, double T,
#                    double (*payoff)(double, double), std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += payoff(ST, K);
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# double monte_carlo_antithetic(int N, double S0, double K, double r, double sigma, double T,
#                               double (*payoff)(double, double), std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST1 = simulate_ST(S0, r, sigma, T, Z);
#         double ST2 = simulate_ST(S0, r, sigma, T, -Z);
#         double payoff_avg = 0.5 * (payoff(ST1, K) + payoff(ST2, K));
#         sum += payoff_avg;
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# double monte_carlo_control_variate(int N, double S0, double K, double r, double sigma, double T,
#                                    double (*payoff)(double, double), std::vector<double>& estimates) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
#     double expected_ST = S0 * exp(r * T);  // Espérance de S_T sous Q
# 
#     for (int i = 1; i <= N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         double payoff_val = payoff(ST, K);
#         double control = ST;
#         double adjusted = payoff_val - (control - expected_ST);  // beta = 1
#         sum += adjusted;
#         estimates.push_back(exp(-r * T) * sum / i);
#     }
#     return exp(-r * T) * sum / N;
# }
# 
# // ===== MAIN =====
# int main() {
#     double S0 = 100.0, K = 100.0, r = 0.05, sigma = 0.2, T = 1.0;
#     int N = 10000;
# 
#     // === Call ===
#     std::vector<double> call_std, call_ant, call_ctrl;
#     double price_call_std  = monte_carlo(N, S0, K, r, sigma, T, payoff_call, call_std);
#     double price_call_ant  = monte_carlo_antithetic(N, S0, K, r, sigma, T, payoff_call, call_ant);
#     double price_call_ctrl = monte_carlo_control_variate(N, S0, K, r, sigma, T, payoff_call, call_ctrl);
#     double bs_call_price = bs_call(S0, K, r, sigma, T);
# 
#     // === Put ===
#     std::vector<double> put_std, put_ant, put_ctrl;
#     double price_put_std  = monte_carlo(N, S0, K, r, sigma, T, payoff_put, put_std);
#     double price_put_ant  = monte_carlo_antithetic(N, S0, K, r, sigma, T, payoff_put, put_ant);
#     double price_put_ctrl = monte_carlo_control_variate(N, S0, K, r, sigma, T, payoff_put, put_ctrl);
#     double bs_put_price = bs_put(S0, K, r, sigma, T);
# 
#     std::cout << std::fixed << std::setprecision(4);
#     std::cout << "==== OPTION CALL ====\n";
#     std::cout << "Prix exact (Black-Scholes)   : " << bs_call_price << "\n";
#     std::cout << "Monte Carlo standard         : " << price_call_std << "\n";
#     std::cout << "Monte Carlo antithétique     : " << price_call_ant << "\n";
#     std::cout << "Monte Carlo variables contrôle : " << price_call_ctrl << "\n\n";
# 
#     std::cout << "==== OPTION PUT ====\n";
#     std::cout << "Prix exact (Black-Scholes)   : " << bs_put_price << "\n";
#     std::cout << "Monte Carlo standard         : " << price_put_std << "\n";
#     std::cout << "Monte Carlo antithétique     : " << price_put_ant << "\n";
#     std::cout << "Monte Carlo variables contrôle : " << price_put_ctrl << "\n";
# 
#     // === Export CSV ===
#     std::ofstream file_call("convergence_comparaison_call.csv");
#     file_call << "N,Standard,Antithetic,Control\n";
#     for (int i = 0; i < N; ++i) {
#         file_call << (i + 1) << "," << call_std[i] << "," << call_ant[i] << "," << call_ctrl[i] << "\n";
#     }
#     file_call.close();
# 
#     std::ofstream file_put("convergence_comparaison_put.csv");
#     file_put << "N,Standard,Antithetic,Control\n";
#     for (int i = 0; i < N; ++i) {
#         file_put << (i + 1) << "," << put_std[i] << "," << put_ant[i] << "," << put_ctrl[i] << "\n";
#     }
#     file_put.close();
# 
#     return 0;
# }
#

!g++ monte_carlo_call_put.cpp -o montecarlo
!./montecarlo

import pandas as pd
import matplotlib.pyplot as plt

# Prix exacts Black-Scholes à ajuster selon les paramètres
bs_call_exact = 10.4506
bs_put_exact = 5.5735

# Lecture des fichiers CSV
call = pd.read_csv("convergence_comparaison_call.csv")
put = pd.read_csv("convergence_comparaison_put.csv")

# === Graphique pour le CALL ===
plt.figure(figsize=(10,5))
plt.plot(call['N'], call['Standard'], label='Standard')
plt.plot(call['N'], call['Antithetic'], label='Antithétique')
plt.plot(call['N'], call['Control'], label='Contrôle')
plt.axhline(bs_call_exact, color='red', linestyle='--', label='Prix exact (BS)')
plt.title("Convergence Monte Carlo – Option Call")
plt.xlabel("Nombre de simulations")
plt.ylabel("Prix estimé")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# === Graphique pour le PUT ===
plt.figure(figsize=(10,5))
plt.plot(put['N'], put['Standard'], label='Standard')
plt.plot(put['N'], put['Antithetic'], label='Antithétique')
plt.plot(put['N'], put['Control'], label='Contrôle')
plt.axhline(bs_put_exact, color='red', linestyle='--', label='Prix exact (BS)')
plt.title("Convergence Monte Carlo – Option Put")
plt.xlabel("Nombre de simulations")
plt.ylabel("Prix estimé")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""greeks

greeks delta
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_delta_compare.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# #include <iomanip>
# 
# // === Payoffs ===
# double payoff_call(double ST, double K) { return std::max(ST - K, 0.0); }
# double payoff_put(double ST, double K) { return std::max(K - ST, 0.0); }
# 
# // === Simulation Black-Scholes ===
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# // === Monte Carlo pricing ===
# double monte_carlo(int N, double S0, double K, double r, double sigma, double T, bool isCall) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
# 
#     for (int i = 0; i < N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += isCall ? payoff_call(ST, K) : payoff_put(ST, K);
#     }
# 
#     return exp(-r * T) * (sum / N);
# }
# 
# // === Delta par différences finies centrées ===
# double estimate_delta(int N, double S0, double K, double r, double sigma, double T, double h, bool isCall) {
#     double up = monte_carlo(N, S0 + h, K, r, sigma, T, isCall);
#     double down = monte_carlo(N, S0 - h, K, r, sigma, T, isCall);
#     return (up - down) / (2 * h);
# }
# 
# // === Fonction de répartition normale ===
# double norm_cdf(double x) {
#     return 0.5 * std::erfc(-x / std::sqrt(2));
# }
# 
# // === Delta théorique Black-Scholes ===
# double bs_delta_call(double S0, double K, double r, double sigma, double T) {
#     double d1 = (log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
#     return norm_cdf(d1);
# }
# double bs_delta_put(double S0, double K, double r, double sigma, double T) {
#     return bs_delta_call(S0, K, r, sigma, T) - 1.0;
# }
# 
# // === MAIN ===
# int main() {
#     double K = 100.0, r = 0.05, sigma = 0.2, T = 1.0;
#     int N = 10000;
#     double h = 0.5;
# 
#     std::ofstream file("delta_vs_theoretical.csv");
#     file << "S0,Delta_MC_Call,Delta_BS_Call,Delta_MC_Put,Delta_BS_Put\n";
# 
#     for (double S0 = 80.0; S0 <= 120.0; S0 += 2.0) {
#         double delta_mc_call = estimate_delta(N, S0, K, r, sigma, T, h, true);
#         double delta_bs_call = bs_delta_call(S0, K, r, sigma, T);
#         double delta_mc_put = estimate_delta(N, S0, K, r, sigma, T, h, false);
#         double delta_bs_put = bs_delta_put(S0, K, r, sigma, T);
# 
#         file << S0 << "," << delta_mc_call << "," << delta_bs_call << ","
#              << delta_mc_put << "," << delta_bs_put << "\n";
#     }
# 
#     file.close();
#     std::cout << "Fichier delta_vs_theoretical.csv généré avec succès.\n";
#     return 0;
# }
#

!g++ monte_carlo_delta_compare.cpp -o delta_compare
!./delta_compare

import pandas as pd
import matplotlib.pyplot as plt

# Chargement des données
df = pd.read_csv("delta_vs_theoretical.csv")

# === Graphique Delta Call ===
plt.figure(figsize=(10,5))
plt.plot(df["S0"], df["Delta_BS_Call"], label="Delta Call Théorique", linestyle='--')
plt.plot(df["S0"], df["Delta_MC_Call"], label="Delta Call (Monte Carlo)", marker='o', markersize=3)
plt.title("Comparaison du Delta - Option Call")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Delta")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# === Graphique Delta Put ===
plt.figure(figsize=(10,5))
plt.plot(df["S0"], df["Delta_BS_Put"], label="Delta Put Théorique", linestyle='--')
plt.plot(df["S0"], df["Delta_MC_Put"], label="Delta Put (Monte Carlo)", marker='o', markersize=3)
plt.title("Comparaison du Delta - Option Put")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Delta")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""gamma"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_gamma_compare.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <vector>
# #include <fstream>
# #include <iomanip>
# 
# double payoff_call(double ST, double K) { return std::max(ST - K, 0.0); }
# double payoff_put(double ST, double K) { return std::max(K - ST, 0.0); }
# 
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# double monte_carlo_price(int N, double S0, double K, double r, double sigma, double T, bool isCall) {
#     std::mt19937 rng(42);
#     std::normal_distribution<double> norm(0.0, 1.0);
#     double sum = 0.0;
# 
#     for (int i = 0; i < N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += isCall ? payoff_call(ST, K) : payoff_put(ST, K);
#     }
# 
#     return exp(-r * T) * (sum / N);
# }
# 
# // Gamma par différences finies centrées
# double estimate_gamma(int N, double S0, double K, double r, double sigma, double T, double h, bool isCall) {
#     double f_up = monte_carlo_price(N, S0 + h, K, r, sigma, T, isCall);
#     double f_mid = monte_carlo_price(N, S0, K, r, sigma, T, isCall);
#     double f_down = monte_carlo_price(N, S0 - h, K, r, sigma, T, isCall);
#     return (f_up - 2 * f_mid + f_down) / (h * h);
# }
# 
# // Gamma théorique (Black-Scholes)
# double bs_gamma(double S0, double K, double r, double sigma, double T) {
#     double d1 = (log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
#     double phi = exp(-0.5 * d1 * d1) / sqrt(2 * M_PI);
#     return phi / (S0 * sigma * sqrt(T));
# }
# 
# int main() {
#     double K = 100.0, r = 0.05, sigma = 0.2, T = 1.0;
#     int N = 10000;
#     double h = 0.5;
# 
#     std::ofstream file("gamma_vs_theoretical.csv");
#     file << "S0,Gamma_MC_Call,Gamma_BS,Gamma_MC_Put,Gamma_BS\n";
# 
#     for (double S0 = 80.0; S0 <= 120.0; S0 += 2.0) {
#         double gamma_mc_call = estimate_gamma(N, S0, K, r, sigma, T, h, true);
#         double gamma_mc_put = estimate_gamma(N, S0, K, r, sigma, T, h, false);
#         double gamma_bs = bs_gamma(S0, K, r, sigma, T);
# 
#         file << S0 << "," << gamma_mc_call << "," << gamma_bs << "," << gamma_mc_put << "," << gamma_bs << "\n";
#     }
# 
#     file.close();
#     std::cout << "Fichier gamma_vs_theoretical.csv généré avec succès.\n";
#     return 0;
# }

!g++ monte_carlo_gamma_compare.cpp -o gamma_compare
!./gamma_compare

import pandas as pd
import matplotlib.pyplot as plt

# Lecture du fichier généré
df = pd.read_csv("gamma_vs_theoretical.csv")

# Gamma pour l’option Call
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Gamma_BS"], label="Gamma Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Gamma_MC_Call"], label="Gamma Call (Monte Carlo)", marker="o")
plt.title("Comparaison du Gamma - Option Call")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Gamma")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Gamma pour l’option Put
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Gamma_BS"], label="Gamma Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Gamma_MC_Put"], label="Gamma Put (Monte Carlo)", marker="o")
plt.title("Comparaison du Gamma - Option Put")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Gamma")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""Vega"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_vega_compare.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <fstream>
# #include <iomanip>
# 
# double payoff_call(double ST, double K) { return std::max(ST - K, 0.0); }
# double payoff_put(double ST, double K) { return std::max(K - ST, 0.0); }
# 
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * exp((r - 0.5 * sigma * sigma) * T + sigma * sqrt(T) * Z);
# }
# 
# double monte_carlo_price(int N, double S0, double K, double r, double sigma, double T, bool isCall) {
#     std::mt19937 rng(42);
#     std::normal_distribution<> norm(0.0, 1.0);
#     double sum = 0.0;
#     for (int i = 0; i < N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += isCall ? payoff_call(ST, K) : payoff_put(ST, K);
#     }
#     return exp(-r * T) * (sum / N);
# }
# 
# double estimate_vega(int N, double S0, double K, double r, double sigma, double T, double h, bool isCall) {
#     double f_up   = monte_carlo_price(N, S0, K, r, sigma + h, T, isCall);
#     double f_down = monte_carlo_price(N, S0, K, r, sigma - h, T, isCall);
#     return (f_up - f_down) / (2.0 * h);
# }
# 
# double bs_vega(double S0, double K, double r, double sigma, double T) {
#     double d1 = (log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * sqrt(T));
#     double phi = exp(-0.5 * d1 * d1) / sqrt(2.0 * M_PI);
#     return S0 * phi * sqrt(T);
# }
# 
# int main() {
#     double K = 100.0, r = 0.05, sigma = 0.2, T = 1.0;
#     int N = 10000;
#     double h = 0.01;
# 
#     std::ofstream file("vega_vs_theoretical.csv");
#     file << "S0,Vega_MC_Call,Vega_BS,Vega_MC_Put,Vega_BS\n";
# 
#     for (double S0 = 80.0; S0 <= 120.0; S0 += 2.0) {
#         double vega_mc_call = estimate_vega(N, S0, K, r, sigma, T, h, true);
#         double vega_mc_put  = estimate_vega(N, S0, K, r, sigma, T, h, false);
#         double vega_bs      = bs_vega(S0, K, r, sigma, T);
# 
#         file << S0 << "," << vega_mc_call << "," << vega_bs << "," << vega_mc_put << "," << vega_bs << "\n";
#     }
# 
#     file.close();
#     std::cout << "Fichier vega_vs_theoretical.csv généré avec succès dans /content/.\n";
#     return 0;
# }
#

!g++ monte_carlo_vega_compare.cpp -o vega_exec
!./vega_exec

import pandas as pd
import matplotlib.pyplot as plt

# ✅ Lecture depuis /content/
df = pd.read_csv("vega_vs_theoretical.csv")

# Graphique Vega Call
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Vega_BS"], label="Vega Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Vega_MC_Call"], label="Vega Call (Monte Carlo)", marker="o")
plt.title("Comparaison du Vega - Option Call")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Vega")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Graphique Vega Put
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Vega_BS"], label="Vega Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Vega_MC_Put"], label="Vega Put (Monte Carlo)", marker="o")
plt.title("Comparaison du Vega - Option Put")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Vega")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""theta"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_theta.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <fstream>
# #include <iomanip>
# 
# // Payoffs
# double payoff_call(double ST, double K) { return std::max(ST - K, 0.0); }
# double payoff_put(double ST, double K) { return std::max(K - ST, 0.0); }
# 
# // Simulation de S_T sous Black-Scholes
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * std::exp((r - 0.5 * sigma * sigma) * T + sigma * std::sqrt(T) * Z);
# }
# 
# // Estimation du prix via Monte Carlo
# double monte_carlo_price(int N, double S0, double K, double r, double sigma, double T, bool isCall) {
#     std::mt19937 rng(42);
#     std::normal_distribution<> norm(0.0, 1.0);
#     double sum = 0.0;
# 
#     for (int i = 0; i < N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += isCall ? payoff_call(ST, K) : payoff_put(ST, K);
#     }
# 
#     return std::exp(-r * T) * (sum / N);
# }
# 
# // Estimation du Theta par différences finies centrées
# double estimate_theta(int N, double S0, double K, double r, double sigma, double T, double h, bool isCall) {
#     double price_up   = monte_carlo_price(N, S0, K, r, sigma, T + h, isCall);
#     double price_down = monte_carlo_price(N, S0, K, r, sigma, T - h, isCall);
#     return (price_down - price_up) / (2.0 * h);  // attention à l'ordre
# }
# 
# // Theta théorique Black-Scholes
# double bs_theta(double S0, double K, double r, double sigma, double T, bool isCall) {
#     double d1 = (std::log(S0 / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * std::sqrt(T));
#     double d2 = d1 - sigma * std::sqrt(T);
#     double phi = std::exp(-0.5 * d1 * d1) / std::sqrt(2 * M_PI);
#     double Nd1 = 0.5 * std::erfc(-d1 / std::sqrt(2));
#     double Nd2 = 0.5 * std::erfc(-d2 / std::sqrt(2));
#     double nphi = S0 * phi * sigma / (2 * std::sqrt(T));
# 
#     if (isCall)
#         return -nphi - r * K * std::exp(-r * T) * Nd2;
#     else
#         return -nphi + r * K * std::exp(-r * T) * (1 - Nd2);
# }
# 
# int main() {
#     double K = 100.0, r = 0.05, sigma = 0.2;
#     int N = 10000;
#     double h = 0.01;
# 
#     std::ofstream file("theta_vs_theoretical.csv");
# 
#     file << "S0,Theta_MC_Call,Theta_BS_Call,Theta_MC_Put,Theta_BS_Put\n";
# 
#     for (double S0 = 80.0; S0 <= 120.0; S0 += 2.0) {
#         double T = 1.0; // maturité constante
#         double theta_mc_call = estimate_theta(N, S0, K, r, sigma, T, h, true);
#         double theta_mc_put  = estimate_theta(N, S0, K, r, sigma, T, h, false);
#         double theta_bs_call = bs_theta(S0, K, r, sigma, T, true);
#         double theta_bs_put  = bs_theta(S0, K, r, sigma, T, false);
# 
#         file << S0 << "," << theta_mc_call << "," << theta_bs_call << "," << theta_mc_put << "," << theta_bs_put << "\n";
#     }
# 
#     file.close();
#     std::cout << "Fichier theta_vs_theoretical.csv généré avec succès.\n";
#     return 0;
# }
#

!g++ monte_carlo_theta.cpp -o monte_carlo_theta
!./monte_carlo_theta

import pandas as pd
import matplotlib.pyplot as plt

# Lecture du fichier CSV généré par le code C++
df = pd.read_csv("theta_vs_theoretical.csv")


# Graphique pour le Theta du Call
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Theta_BS_Call"], label="Theta Call Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Theta_MC_Call"], label="Theta Call Monte Carlo", marker="o")
plt.title("Comparaison du Theta - Option Call")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Theta")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Graphique pour le Theta du Put
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Theta_BS_Put"], label="Theta Put Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Theta_MC_Put"], label="Theta Put Monte Carlo", marker="o")
plt.title("Comparaison du Theta - Option Put")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Theta")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""rho

"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile monte_carlo_rho.cpp
# #include <iostream>
# #include <cmath>
# #include <random>
# #include <fstream>
# #include <iomanip>
# 
# // Fonctions de payoff
# double payoff_call(double ST, double K) { return std::max(ST - K, 0.0); }
# double payoff_put(double ST, double K)  { return std::max(K - ST, 0.0); }
# 
# // Simulation de S_T sous Black-Scholes
# double simulate_ST(double S0, double r, double sigma, double T, double Z) {
#     return S0 * std::exp((r - 0.5 * sigma * sigma) * T + sigma * std::sqrt(T) * Z);
# }
# 
# // Prix Monte Carlo
# double monte_carlo_price(int N, double S0, double K, double r, double sigma, double T, bool isCall) {
#     std::mt19937 rng(42);
#     std::normal_distribution<> norm(0.0, 1.0);
#     double sum = 0.0;
# 
#     for (int i = 0; i < N; ++i) {
#         double Z = norm(rng);
#         double ST = simulate_ST(S0, r, sigma, T, Z);
#         sum += isCall ? payoff_call(ST, K) : payoff_put(ST, K);
#     }
# 
#     return std::exp(-r * T) * (sum / N);
# }
# 
# // Estimation du Rho par différences finies centrées
# double estimate_rho(int N, double S0, double K, double r, double sigma, double T, double h, bool isCall) {
#     double price_up   = monte_carlo_price(N, S0, K, r + h, sigma, T, isCall);
#     double price_down = monte_carlo_price(N, S0, K, r - h, sigma, T, isCall);
#     return (price_up - price_down) / (2.0 * h);
# }
# 
# // Rho théorique (Black-Scholes)
# double bs_rho(double S0, double K, double r, double sigma, double T, bool isCall) {
#     double d2 = (std::log(S0 / K) + (r - 0.5 * sigma * sigma) * T) / (sigma * std::sqrt(T));
#     double Nd2 = 0.5 * std::erfc(-d2 / std::sqrt(2));
#     double Nnd2 = 0.5 * std::erfc(d2 / std::sqrt(2)); // N(-d2)
#     if (isCall)
#         return T * K * std::exp(-r * T) * Nd2;
#     else
#         return -T * K * std::exp(-r * T) * Nnd2;
# }
# 
# int main() {
#     double K = 100.0, sigma = 0.2, T = 1.0;
#     int N = 10000;
#     double h = 0.01;
# 
# 
#     std::ofstream file("rho_vs_theoretical.csv");
#     file << "S0,Rho_MC_Call,Rho_BS_Call,Rho_MC_Put,Rho_BS_Put\n";
# 
#     for (double S0 = 80.0; S0 <= 120.0; S0 += 2.0) {
#         double r = 0.05;
#         double rho_mc_call = estimate_rho(N, S0, K, r, sigma, T, h, true);
#         double rho_mc_put  = estimate_rho(N, S0, K, r, sigma, T, h, false);
#         double rho_bs_call = bs_rho(S0, K, r, sigma, T, true);
#         double rho_bs_put  = bs_rho(S0, K, r, sigma, T, false);
# 
#         file << S0 << "," << rho_mc_call << "," << rho_bs_call << "," << rho_mc_put << "," << rho_bs_put << "\n";
#     }
# 
#     file.close();
#     std::cout << "Fichier rho_vs_theoretical.csv généré avec succès.\n";
#     return 0;
# }
#

!g++ monte_carlo_rho.cpp -o monte_carlo_rho
!./monte_carlo_rho

import pandas as pd
import matplotlib.pyplot as plt

# Lecture du fichier CSV généré par le code C++

df = pd.read_csv("rho_vs_theoretical.csv")

# Tracé pour le Call
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Rho_BS_Call"], label="Rho Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Rho_MC_Call"], label="Rho Call (Monte Carlo)", marker="o")
plt.title("Comparaison du Rho - Option Call")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Rho")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Tracé pour le Put
plt.figure(figsize=(10, 5))
plt.plot(df["S0"], df["Rho_BS_Put"], label="Rho Théorique (BS)", linestyle="--")
plt.plot(df["S0"], df["Rho_MC_Put"], label="Rho Put (Monte Carlo)", marker="o")
plt.title("Comparaison du Rho - Option Put")
plt.xlabel("Prix initial du sous-jacent $S_0$")
plt.ylabel("Rho")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()