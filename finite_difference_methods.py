# -*- coding: utf-8 -*-
"""Finite Difference Methods

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18bRSleinbHu5CabeECUZJwZ13plOnhqu

schema implicit
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile bs_call_put.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Paramètres du problème
# const double S0 = 100.0;
# const double K = 100.0;
# const double T = 1.0;
# const double r = 0.05;
# const double sigma = 0.2;
# const int N = 200;
# const int M = 500;
# const double x_min = -3.0;
# const double x_max = 1.0;
# 
# double tau_max = (sigma*sigma/2.0)*T;
# double alpha = 0.5 - r / (sigma*sigma);
# double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
# 
# // Thomas algorithm
# void solve_tridiagonal(const std::vector<double>& lower,
#                        const std::vector<double>& diag,
#                        const std::vector<double>& upper,
#                        std::vector<double>& rhs,
#                        std::vector<double>& solution) {
#     int n = diag.size();
#     std::vector<double> c_prime(n, 0.0);
#     std::vector<double> d_prime(n, 0.0);
# 
#     c_prime[0] = upper[0] / diag[0];
#     d_prime[0] = rhs[0] / diag[0];
# 
#     for (int i = 1; i < n; i++) {
#         double m = diag[i] - lower[i] * c_prime[i-1];
#         c_prime[i] = (i < n-1) ? upper[i] / m : 0.0;
#         d_prime[i] = (rhs[i] - lower[i] * d_prime[i-1]) / m;
#     }
# 
#     solution[n-1] = d_prime[n-1];
#     for (int i = n-2; i >= 0; i--) {
#         solution[i] = d_prime[i] - c_prime[i] * solution[i+1];
#     }
# }
# 
# // Fonction générale pour résoudre
# void solve_option(bool is_call, std::string filename) {
# 
#     double dx = (x_max - x_min) / N;
#     double dtau = tau_max / M;
#     double lambda = dtau / (dx*dx);
# 
#     std::vector<double> x(N+1, 0.0);
#     for (int i = 0; i <= N; i++)
#         x[i] = x_min + i*dx;
# 
#     // Condition initiale (call ou put)
#     std::vector<double> u(N+1, 0.0);
#     for (int i = 0; i <= N; i++) {
#         if (is_call)
#             u[i] = std::max(exp(x[i]) - 1.0, 0.0);
#         else
#             u[i] = std::max(1.0 - exp(x[i]), 0.0);
#     }
# 
#     std::vector<double> lower(N-1, -lambda);
#     std::vector<double> diag(N-1, 1.0 + 2.0*lambda);
#     std::vector<double> upper(N-1, -lambda);
#     std::vector<double> rhs(N-1), solution(N-1);
# 
#     for (int n = 0; n < M; n++) {
#         for (int i = 1; i < N; i++)
#             rhs[i-1] = u[i];
#         rhs[0]  += lambda * u[0];
#         rhs[N-2] += lambda * u[N];
# 
#         solve_tridiagonal(lower, diag, upper, rhs, solution);
#         for (int i = 1; i < N; i++)
#             u[i] = solution[i-1];
# 
#         // conditions de bord basiques
#         u[0] = 0.0;
#         u[N] = (is_call ? exp(x_max) - 1.0 : 0.0);
#     }
# 
#     std::vector<double> S(N+1), F(N+1);
#     for (int i = 0; i <= N; i++) {
#         S[i] = K * exp(x[i]);
#         F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#     }
# 
#     std::ofstream file(filename);
#     for (int i = 0; i <= N; i++) {
#         file << S[i] << "," << F[i] << "\n";
#     }
#     file.close();
# }
# 
# int main() {
#     solve_option(true, "call.csv");
#     solve_option(false, "put.csv");
#     std::cout << "Résolution terminée (call et put)." << std::endl;
#     return 0;
# }
#

!g++ bs_call_put.cpp -o bs_call_put

!./bs_call_put

import numpy as np
import matplotlib.pyplot as plt

# Lecture des fichiers
data_call = np.loadtxt("call.csv", delimiter=",")
data_put  = np.loadtxt("put.csv", delimiter=",")

S_call = data_call[:,0]
F_call = data_call[:,1]
S_put  = data_put[:,0]
F_put  = data_put[:,1]

plt.figure(figsize=(10,6))
plt.plot(S_call, F_call, label="Call européen (implicite C++)", linewidth=2)
plt.plot(S_put, F_put, label="Put européen (implicite C++)", linewidth=2)
plt.xlabel("Prix du sous-jacent $S$")
plt.ylabel("Prix de l'option $F(t,S)$")
plt.title("Prix Call & Put européens par schéma implicite (C++)")
plt.grid(True)
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile convergence.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Fonction initiale (payoff call transformé)
# double initial_condition(double x) {
#     return std::max(exp(x) - 1.0, 0.0);
# }
# 
# // Méthode de Thomas
# void solve_tridiagonal(const std::vector<double>& lower,
#                        const std::vector<double>& diag,
#                        const std::vector<double>& upper,
#                        std::vector<double>& rhs,
#                        std::vector<double>& solution) {
# 
#     int n = diag.size();
#     std::vector<double> c_prime(n, 0.0);
#     std::vector<double> d_prime(n, 0.0);
# 
#     c_prime[0] = upper[0] / diag[0];
#     d_prime[0] = rhs[0] / diag[0];
# 
#     for (int i = 1; i < n; i++) {
#         double m = diag[i] - lower[i] * c_prime[i-1];
#         c_prime[i] = (i < n-1) ? upper[i] / m : 0.0;
#         d_prime[i] = (rhs[i] - lower[i] * d_prime[i-1]) / m;
#     }
# 
#     solution[n-1] = d_prime[n-1];
#     for (int i = n-2; i >= 0; i--)
#         solution[i] = d_prime[i] - c_prime[i] * solution[i+1];
# }
# 
# int main() {
# 
#     const double S0 = 100.0, K = 100.0, T = 1.0, r = 0.05, sigma = 0.2;
#     const int M = 500;  // nombre de pas de temps
#     const double x_min = -3.0, x_max = 1.0;
# 
#     double tau_max = (sigma*sigma/2.0)*T;
#     double alpha = 0.5 - r / (sigma*sigma);
#     double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
# 
#     std::ofstream file("convergence.csv");
#     file << "N,error\n";
# 
#     for (int N = 20; N <= 400; N += 20) {
# 
#         double dx = (x_max - x_min) / N;
#         double dtau = tau_max / M;
#         double lambda = dtau / (dx*dx);
# 
#         std::vector<double> x(N+1);
#         for (int i = 0; i <= N; i++)
#             x[i] = x_min + i*dx;
# 
#         std::vector<double> u(N+1);
#         for (int i = 0; i <= N; i++)
#             u[i] = initial_condition(x[i]);
# 
#         std::vector<double> lower(N-1, -lambda);
#         std::vector<double> diag(N-1, 1.0 + 2.0*lambda);
#         std::vector<double> upper(N-1, -lambda);
#         std::vector<double> rhs(N-1), solution(N-1);
# 
#         for (int n = 0; n < M; n++) {
#             for (int i = 1; i < N; i++)
#                 rhs[i-1] = u[i];
# 
#             rhs[0]  += lambda * u[0];
#             rhs[N-2] += lambda * u[N];
# 
#             solve_tridiagonal(lower, diag, upper, rhs, solution);
#             for (int i = 1; i < N; i++)
#                 u[i] = solution[i-1];
# 
#             u[0] = 0.0;
#             u[N] = exp(x_max) - 1.0;
#         }
# 
#         std::vector<double> S(N+1), F(N+1);
#         for (int i = 0; i <= N; i++) {
#             S[i] = K * exp(x[i]);
#             F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#         }
# 
#         // interpolation pour récupérer le prix en S0
#         double price_num = 0.0;
#         for (int i = 0; i < N; i++) {
#             if (S0 >= S[i] && S0 <= S[i+1]) {
#                 double w = (S0 - S[i]) / (S[i+1] - S[i]);
#                 price_num = (1 - w)*F[i] + w*F[i+1];
#                 break;
#             }
#         }
# 
#         // prix exact Black-Scholes
#         double d1 = (log(S0/K) + (r + 0.5*sigma*sigma)*T) / (sigma*sqrt(T));
#         double d2 = d1 - sigma*sqrt(T);
#         double Nd1 = 0.5 * (1.0 + erf(d1 / sqrt(2.0)));
#         double Nd2 = 0.5 * (1.0 + erf(d2 / sqrt(2.0)));
# 
#         double price_exact = S0 * Nd1 - K * exp(-r*T) * Nd2;
# 
#         double error = fabs(price_num - price_exact);
# 
#         file << N << "," << error << "\n";
#     }
# 
#     file.close();
#     std::cout << "Convergence calculée." << std::endl;
# 
#     return 0;
# }
#

!g++ convergence.cpp -o convergence

!./convergence

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress

data = np.loadtxt("convergence.csv", delimiter=",", skiprows=1)
N = data[:, 0]
errors = data[:, 1]

logN = np.log(N)
logE = np.log(errors)

slope, intercept, r_value, p_value, std_err = linregress(logN, logE)
ordre_convergence = -slope

plt.figure(figsize=(8,5))
plt.loglog(N, errors, marker='o', linewidth=2)
plt.xlabel("Nombre de points en espace (N)")
plt.ylabel("Erreur absolue")
plt.title("Convergence numérique du schéma implicite")
#plt.grid(True, which="both")
plt.show()

print(f"Ordre de convergence estimé : p ≈ {ordre_convergence:.4f}")

"""Schema explicit"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile bs_explicit.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Paramètres du problème
# const double S0 = 100.0;
# const double K = 100.0;
# const double T = 1.0;
# const double r = 0.05;
# const double sigma = 0.2;
# const int N = 200;
# const double x_min = -3.0;
# const double x_max = 1.0;
# const double theta = 0.4; // marge de sécurité pour stabilité
# 
# double tau_max = (sigma*sigma/2.0)*T;
# double alpha = 0.5 - r / (sigma*sigma);
# double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
# 
# // Fonction initiale générale pour call et put
# double initial_condition(double x, bool is_call) {
#     if (is_call)
#         return std::max(exp(x) - 1.0, 0.0);
#     else
#         return std::max(1.0 - exp(x), 0.0);
# }
# 
# // Fonction de résolution explicite
# void solve_explicit(bool is_call, std::string filename) {
# 
#     double dx = (x_max - x_min) / N;
#     double dtau = theta * dx * dx;  // condition de stabilité respectée
#     int M = static_cast<int>(tau_max / dtau) + 1;
#     dtau = tau_max / M;  // recalcul exact pour tomber juste
# 
#     double lambda = dtau / (dx*dx);
# 
#     std::vector<double> x(N+1);
#     for (int i = 0; i <= N; i++)
#         x[i] = x_min + i*dx;
# 
#     std::vector<double> u(N+1);
#     for (int i = 0; i <= N; i++)
#         u[i] = initial_condition(x[i], is_call);
# 
#     std::vector<double> u_new(N+1);
# 
#     for (int n = 0; n < M; n++) {
#         for (int i = 1; i < N; i++)
#             u_new[i] = u[i] + lambda * (u[i+1] - 2.0*u[i] + u[i-1]);
# 
#         // conditions aux bords
#         u_new[0] = 0.0;
#         u_new[N] = (is_call ? exp(x_max)-1.0 : 0.0);
# 
#         u = u_new;
#     }
# 
#     std::vector<double> S(N+1), F(N+1);
#     for (int i = 0; i <= N; i++) {
#         S[i] = K * exp(x[i]);
#         F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#     }
# 
#     std::ofstream file(filename);
#     for (int i = 0; i <= N; i++)
#         file << S[i] << "," << F[i] << "\n";
#     file.close();
# }
# 
# int main() {
#     solve_explicit(true, "call.csv");
#     solve_explicit(false, "put.csv");
#     std::cout << "Schéma explicite terminé (call et put)." << std::endl;
#     return 0;
# }
#

!g++ bs_explicit.cpp -o bs_explicit
!./bs_explicit

import numpy as np
import matplotlib.pyplot as plt

# Lecture des fichiers générés
data_call = np.loadtxt("call.csv", delimiter=",")
data_put  = np.loadtxt("put.csv", delimiter=",")

S_call = data_call[:,0]
F_call = data_call[:,1]
S_put  = data_put[:,0]
F_put  = data_put[:,1]

plt.figure(figsize=(10,6))
plt.plot(S_call, F_call, label="Call européen (explicite C++)", linewidth=2)
plt.plot(S_put, F_put, label="Put européen (explicite C++)", linewidth=2)
plt.xlabel("Prix du sous-jacent $S$")
plt.ylabel("Prix de l'option $F(t,S)$")
plt.title("Prix Call & Put via schéma explicite (C++)")
plt.grid(True)
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile convergence_explicit.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Payoff transformé (call européen)
# double initial_condition(double x) {
#     return std::max(exp(x) - 1.0, 0.0);
# }
# 
# int main() {
# 
#     const double S0 = 100.0, K = 100.0, T = 1.0, r = 0.05, sigma = 0.2;
#     const double x_min = -3.0, x_max = 1.0;
#     const double tau_max = (sigma*sigma/2.0)*T;
#     const double alpha = 0.5 - r / (sigma*sigma);
#     const double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
#     const double theta = 0.4;  // marge de sécurité stabilité
# 
#     std::ofstream file("convergence_explicit.csv");
#     file << "N,error\n";
# 
#     for (int N = 20; N <= 400; N += 20) {
# 
#         double dx = (x_max - x_min) / N;
#         double dtau = theta * dx * dx;
#         int M = static_cast<int>(tau_max / dtau) + 1;
#         dtau = tau_max / M;
#         double lambda = dtau / (dx*dx);
# 
#         std::vector<double> x(N+1);
#         for (int i = 0; i <= N; i++)
#             x[i] = x_min + i*dx;
# 
#         std::vector<double> u(N+1);
#         for (int i = 0; i <= N; i++)
#             u[i] = initial_condition(x[i]);
# 
#         std::vector<double> u_new(N+1);
# 
#         for (int n = 0; n < M; n++) {
#             for (int i = 1; i < N; i++)
#                 u_new[i] = u[i] + lambda * (u[i+1] - 2.0*u[i] + u[i-1]);
# 
#             u_new[0] = 0.0;
#             u_new[N] = exp(x_max) - 1.0;
#             u = u_new;
#         }
# 
#         std::vector<double> S(N+1), F(N+1);
#         for (int i = 0; i <= N; i++) {
#             S[i] = K * exp(x[i]);
#             F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#         }
# 
#         double price_num = 0.0;
#         for (int i = 0; i < N; i++) {
#             if (S0 >= S[i] && S0 <= S[i+1]) {
#                 double w = (S0 - S[i]) / (S[i+1] - S[i]);
#                 price_num = (1 - w)*F[i] + w*F[i+1];
#                 break;
#             }
#         }
# 
#         double d1 = (log(S0/K) + (r + 0.5*sigma*sigma)*T) / (sigma*sqrt(T));
#         double d2 = d1 - sigma*sqrt(T);
#         double Nd1 = 0.5 * (1.0 + erf(d1 / sqrt(2.0)));
#         double Nd2 = 0.5 * (1.0 + erf(d2 / sqrt(2.0)));
# 
#         double price_exact = S0 * Nd1 - K * exp(-r*T) * Nd2;
# 
#         double error = fabs(price_num - price_exact);
#         file << N << "," << error << "\n";
#     }
# 
#     file.close();
#     std::cout << "Convergence explicite calculée." << std::endl;
# 
#     return 0;
# }
#

!g++ convergence_explicit.cpp -o convergence_explicit
!./convergence_explicit

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress

data = np.loadtxt("convergence_explicit.csv", delimiter=",", skiprows=1)
N = data[:, 0]
errors = data[:, 1]

logN = np.log(N)
logE = np.log(errors)

slope, intercept, r_value, p_value, std_err = linregress(logN, logE)
ordre_convergence = -slope

plt.figure(figsize=(8,5))
plt.loglog(N, errors, marker='o', linewidth=2)
plt.xlabel("Nombre de points en espace (N)")
plt.ylabel("Erreur absolue")
plt.title("Convergence numérique du schéma explicite")
#plt.grid(True, which="both")
plt.show()

print(f"Ordre de convergence estimé : p ≈ {ordre_convergence:.4f}")

"""crank nicolson"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile bs_crank_nicolson.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Paramètres du problème
# const double S0 = 100.0;
# const double K = 100.0;
# const double T = 1.0;
# const double r = 0.05;
# const double sigma = 0.2;
# const int N = 200;
# const int M = 500;
# const double x_min = -3.0;
# const double x_max = 1.0;
# 
# double tau_max = (sigma*sigma/2.0)*T;
# double alpha = 0.5 - r / (sigma*sigma);
# double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
# 
# // Algorithme de Thomas pour système tridiagonal
# void solve_tridiagonal(const std::vector<double>& lower,
#                        const std::vector<double>& diag,
#                        const std::vector<double>& upper,
#                        std::vector<double>& rhs,
#                        std::vector<double>& solution) {
# 
#     int n = diag.size();
#     std::vector<double> c_prime(n, 0.0);
#     std::vector<double> d_prime(n, 0.0);
# 
#     c_prime[0] = upper[0] / diag[0];
#     d_prime[0] = rhs[0] / diag[0];
# 
#     for (int i = 1; i < n; i++) {
#         double m = diag[i] - lower[i] * c_prime[i-1];
#         c_prime[i] = (i < n-1) ? upper[i] / m : 0.0;
#         d_prime[i] = (rhs[i] - lower[i] * d_prime[i-1]) / m;
#     }
# 
#     solution[n-1] = d_prime[n-1];
#     for (int i = n-2; i >= 0; i--)
#         solution[i] = d_prime[i] - c_prime[i] * solution[i+1];
# }
# 
# // Résolution Crank-Nicolson pour call et put
# void solve_CN(bool is_call, std::string filename) {
# 
#     double dx = (x_max - x_min) / N;
#     double dtau = tau_max / M;
#     double lambda = dtau / (dx*dx);
# 
#     std::vector<double> x(N+1);
#     for (int i = 0; i <= N; i++)
#         x[i] = x_min + i*dx;
# 
#     // Condition initiale (payoff transformé)
#     std::vector<double> u(N+1);
#     for (int i = 0; i <= N; i++) {
#         if (is_call)
#             u[i] = std::max(exp(x[i]) - 1.0, 0.0);
#         else
#             u[i] = std::max(1.0 - exp(x[i]), 0.0);
#     }
# 
#     // Matrices A et B
#     std::vector<double> lower_A(N-1, -lambda/2);
#     std::vector<double> diag_A(N-1, 1 + lambda);
#     std::vector<double> upper_A(N-1, -lambda/2);
# 
#     std::vector<double> lower_B(N-1, lambda/2);
#     std::vector<double> diag_B(N-1, 1 - lambda);
#     std::vector<double> upper_B(N-1, lambda/2);
# 
#     std::vector<double> rhs(N-1), solution(N-1);
# 
#     for (int n = 0; n < M; n++) {
# 
#         // Construction du second membre rhs = B * u^n
#         for (int i = 1; i < N; i++)
#             rhs[i-1] = lower_B[i-1]*u[i-1] + diag_B[i-1]*u[i] + upper_B[i-1]*u[i+1];
# 
#         // Conditions aux bords
#         rhs[0]  += (lambda/2) * u[0];
#         rhs[N-2] += (lambda/2) * u[N];
# 
#         // Résolution tridiagonale
#         solve_tridiagonal(lower_A, diag_A, upper_A, rhs, solution);
# 
#         for (int i = 1; i < N; i++)
#             u[i] = solution[i-1];
# 
#         u[0] = 0.0;
#         u[N] = (is_call ? exp(x_max)-1.0 : 0.0);
#     }
# 
#     // Reconstruction du prix d'option original
#     std::vector<double> S(N+1), F(N+1);
#     for (int i = 0; i <= N; i++) {
#         S[i] = K * exp(x[i]);
#         F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#     }
# 
#     std::ofstream file(filename);
#     for (int i = 0; i <= N; i++)
#         file << S[i] << "," << F[i] << "\n";
#     file.close();
# }
# 
# int main() {
#     solve_CN(true, "call_CN.csv");
#     solve_CN(false, "put_CN.csv");
#     std::cout << "Schéma Crank-Nicolson terminé (call et put)." << std::endl;
#     return 0;
# }
#

!g++ bs_crank_nicolson.cpp -o bs_crank_nicolson
!./bs_crank_nicolson

import numpy as np
import matplotlib.pyplot as plt

data_call = np.loadtxt("call_CN.csv", delimiter=",")
data_put  = np.loadtxt("put_CN.csv", delimiter=",")

S_call = data_call[:,0]
F_call = data_call[:,1]
S_put  = data_put[:,0]
F_put  = data_put[:,1]

plt.figure(figsize=(10,6))
plt.plot(S_call, F_call, label="Call européen (Crank-Nicolson C++)", linewidth=2)
plt.plot(S_put, F_put, label="Put européen (Crank-Nicolson C++)", linewidth=2)
plt.xlabel("Prix du sous-jacent $S$")
plt.ylabel("Prix de l'option $F(t,S)$")
plt.title("Pricing Call & Put via Crank-Nicolson (C++)")
plt.grid(True)
plt.legend()
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile convergence_CN.cpp
# 
# #include <iostream>
# #include <vector>
# #include <cmath>
# #include <fstream>
# #include <algorithm>
# 
# // Fonction initiale (payoff transformé call)
# double initial_condition(double x) {
#     return std::max(exp(x) - 1.0, 0.0);
# }
# 
# // Méthode de Thomas
# void solve_tridiagonal(const std::vector<double>& lower,
#                        const std::vector<double>& diag,
#                        const std::vector<double>& upper,
#                        std::vector<double>& rhs,
#                        std::vector<double>& solution) {
# 
#     int n = diag.size();
#     std::vector<double> c_prime(n, 0.0);
#     std::vector<double> d_prime(n, 0.0);
# 
#     c_prime[0] = upper[0] / diag[0];
#     d_prime[0] = rhs[0] / diag[0];
# 
#     for (int i = 1; i < n; i++) {
#         double m = diag[i] - lower[i] * c_prime[i-1];
#         c_prime[i] = (i < n-1) ? upper[i] / m : 0.0;
#         d_prime[i] = (rhs[i] - lower[i] * d_prime[i-1]) / m;
#     }
# 
#     solution[n-1] = d_prime[n-1];
#     for (int i = n-2; i >= 0; i--)
#         solution[i] = d_prime[i] - c_prime[i] * solution[i+1];
# }
# 
# int main() {
# 
#     const double S0 = 100.0, K = 100.0, T = 1.0, r = 0.05, sigma = 0.2;
#     const double x_min = -3.0, x_max = 1.0;
#     const double tau_max = (sigma*sigma/2.0)*T;
#     const double alpha = 0.5 - r / (sigma*sigma);
#     const double beta = -(alpha*alpha + alpha - 2*r/(sigma*sigma));
#     const int M = 500;
# 
#     std::ofstream file("convergence_CN.csv");
#     file << "N,error\n";
# 
#     for (int N = 20; N <= 400; N += 20) {
# 
#         double dx = (x_max - x_min) / N;
#         double dtau = tau_max / M;
#         double lambda = dtau / (dx*dx);
# 
#         std::vector<double> x(N+1);
#         for (int i = 0; i <= N; i++)
#             x[i] = x_min + i*dx;
# 
#         std::vector<double> u(N+1);
#         for (int i = 0; i <= N; i++)
#             u[i] = initial_condition(x[i]);
# 
#         std::vector<double> lower_A(N-1, -lambda/2);
#         std::vector<double> diag_A(N-1, 1 + lambda);
#         std::vector<double> upper_A(N-1, -lambda/2);
# 
#         std::vector<double> lower_B(N-1, lambda/2);
#         std::vector<double> diag_B(N-1, 1 - lambda);
#         std::vector<double> upper_B(N-1, lambda/2);
# 
#         std::vector<double> rhs(N-1), solution(N-1);
# 
#         for (int n = 0; n < M; n++) {
#             for (int i = 1; i < N; i++)
#                 rhs[i-1] = lower_B[i-1]*u[i-1] + diag_B[i-1]*u[i] + upper_B[i-1]*u[i+1];
# 
#             rhs[0]  += (lambda/2) * u[0];
#             rhs[N-2] += (lambda/2) * u[N];
# 
#             solve_tridiagonal(lower_A, diag_A, upper_A, rhs, solution);
# 
#             for (int i = 1; i < N; i++)
#                 u[i] = solution[i-1];
# 
#             u[0] = 0.0;
#             u[N] = exp(x_max) - 1.0;
#         }
# 
#         std::vector<double> S(N+1), F(N+1);
#         for (int i = 0; i <= N; i++) {
#             S[i] = K * exp(x[i]);
#             F[i] = K * exp(-alpha * x[i] - beta * tau_max) * u[i];
#         }
# 
#         double price_num = 0.0;
#         for (int i = 0; i < N; i++) {
#             if (S0 >= S[i] && S0 <= S[i+1]) {
#                 double w = (S0 - S[i]) / (S[i+1] - S[i]);
#                 price_num = (1 - w)*F[i] + w*F[i+1];
#                 break;
#             }
#         }
# 
#         double d1 = (log(S0/K) + (r + 0.5*sigma*sigma)*T) / (sigma*sqrt(T));
#         double d2 = d1 - sigma*sqrt(T);
#         double Nd1 = 0.5 * (1.0 + erf(d1 / sqrt(2.0)));
#         double Nd2 = 0.5 * (1.0 + erf(d2 / sqrt(2.0)));
# 
#         double price_exact = S0 * Nd1 - K * exp(-r*T) * Nd2;
#         double error = fabs(price_num - price_exact);
#         file << N << "," << error << "\n";
#     }
# 
#     file.close();
#     std::cout << "Convergence Crank-Nicolson calculée." << std::endl;
# 
#     return 0;
# }
#

!g++ convergence_CN.cpp -o convergence_CN
!./convergence_CN

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import linregress

data = np.loadtxt("convergence_CN.csv", delimiter=",", skiprows=1)
N = data[:, 0]
errors = data[:, 1]

logN = np.log(N)
logE = np.log(errors)

slope, intercept, r_value, p_value, std_err = linregress(logN, logE)
ordre_convergence = -slope

plt.figure(figsize=(8,5))
plt.loglog(N, errors, marker='o', linewidth=2)
plt.xlabel("Nombre de points en espace (N)")
plt.ylabel("Erreur absolue")
plt.title("Convergence numérique du schéma Crank-Nicolson")
#plt.grid(True, which="both")
plt.show()

print(f"Ordre de convergence estimé : p ≈ {ordre_convergence:.4f}")